<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="google-site-verification" content="VOdSVFLZgu5oX1fWGwT5OkE9QF-b6k3XMEZIkFIuiTA" />

<title>Golangで大きなcsvのインポートを速くする - ◯ △ □</title>

<link rel="icon" href="https://blog.yudppp.com/img/favicon.png">
<link rel="shortcut icon" href="https://blog.yudppp.com/img/favicon.png">
<link rel="stylesheet" href="https://blog.yudppp.com/css/lib.min.css">
<link rel="stylesheet" href="https://blog.yudppp.com/css/app.min.css">
<link rel="alternate" href="https://blog.yudppp.com/index.xml" title="" type="application/rss+xml">

<meta property="og:type", content="article">
<meta property="og:url", content="https://blog.yudppp.com/posts/csv_fast_upload/">
<meta property="og:site_name", content="◯ △ □">
<meta property="og:title", content="Golangで大きなcsvのインポートを速くする">


  <meta name="description" content="はじめに Golangで大きなcsvファイルをパースして諸々の処理をしてインポートをする処理を書いていたのですが、明らかに遅く5分以上かかる処理になっていました。 そこでgoルーチンを導入して並列で実行することによって効率化を図りました。
対応前 func main() { // 1度に取得する量 bulkCount := 100 file, _ := os.Open(&quot;./data.csv&quot;) defer file.Close() reader := csv.NewReader(file) // ヘッダー行の取得 header, _ := reader.Read() for { lines := make([][]string, 0, bulkCount) isLast := false for i := 0; i &lt; bulkCount; i&#43;&#43; { line, err := reader.Read() if err == io.EOF { isLast = true break } else if err != nil { panic(err) } lines = append(lines, line) } exec(lines) if isLast { break } } }  *一部のエラーは可読性のため捨てています">


  </head>
  <body class="hack">
    <header>
  <div class="container">
    
    <div class="nav">
      <div class="nav__left">
        <span class="nav__item">
          <a class="nocolor" href="https://blog.yudppp.com">
            <canvas class="mini-logo" width="150" height="50">
          </a>
        </span>
      </div>
    </div>
    <div class="title">
      <h1>Golangで大きなcsvのインポートを速くする</h1>
    </div>
    
  </div>
</header>

    <main>
      <div class="container">
        <date>2016.10.17</date>
        <div class="content">
          

<h2 id="はじめに">はじめに</h2>

<p>Golangで大きなcsvファイルをパースして諸々の処理をしてインポートをする処理を書いていたのですが、明らかに遅く5分以上かかる処理になっていました。
そこでgoルーチンを導入して並列で実行することによって効率化を図りました。</p>

<h2 id="対応前">対応前</h2>

<pre><code class="language-go">func main() {
	// 1度に取得する量
	bulkCount := 100

	file, _ := os.Open(&quot;./data.csv&quot;)
	defer file.Close()

	reader := csv.NewReader(file)

	// ヘッダー行の取得
	header, _ := reader.Read()

	for {
		lines := make([][]string, 0, bulkCount)
		isLast := false
		for i := 0; i &lt; bulkCount; i++ {
			line, err := reader.Read()
			if err == io.EOF {
				isLast = true
				break
			} else if err != nil {
				panic(err)
			}
			lines = append(lines, line)
		}
        
		exec(lines)

		if isLast {
			break
		}
	}
}

</code></pre>

<p>*一部のエラーは可読性のため捨てています</p>

<p>元のコードはこのようなになっていて、件数が多く、<code>exec(lines)</code>の処理が重いせいもあり、やたら時間がかかってしまっていました。</p>

<h2 id="対応について">対応について</h2>

<p>下記のコードはよくよくない例として出されるコードです。</p>

<pre><code class="language-go">func main() {
	reader := csv.NewReader(file)
	...
	for {
		lines, isLast, err := getLines()
		...
		go exec(lines)
		...
	}
}

func getLines(reader io.Reader) ([]string, bool, err){
	lines := make([][]string, 0, bulkCount)
	isLast := false
	for i := 0; i &lt; bulkCount; i++ {
		line, err := reader.Read(reader)
		if err == io.EOF {
			isLast = true
			break
		} else if err != nil {
			return nil, false, err
		}
		lines = append(lines, line)
	}
	return lines, isLast, err
}
</code></pre>

<p>ほとんどのコードは変えずに並列で実行したい関数のみgoroutineで動かします。
このようにするとgoroutineが増えすぎて問題が起きてしまいます。</p>

<p>そのためgoroutineの数が制御できるようにしていきます。</p>

<pre><code>func main() {
	reader := csv.NewReader(file)
	var wg sync.WaitGroup
	for i := 0; i &lt; 10; i++ {
		wg.Add(1)
		go func() {
			for {
				lines, isLast, err := getLines(reader)
				...
				exec(lines)
				if isLast {
					wg.Done()
				}
			}
		}
	}
}

func getLines(reader io.Reader) ([]string, bool, err){
	lines := make([][]string, 0, bulkCount)
	isLast := false
	for i := 0; i &lt; bulkCount; i++ {
		line, err := reader.Read()
		if err == io.EOF {
			isLast = true
			break
		} else if err != nil {
			return nil, false, err
		}
		lines = append(lines, line)
	}
	return lines, isLast, err
}
</code></pre>

<p>のようにgoroutineを動かす固定すると安全に動かす事ができます。</p>

<p>ただし上記のようなコードを実行した際に</p>

<pre><code>line, err := reader.Read()
</code></pre>

<p>の箇所でエラーが出てしまう事がありました。</p>

<p>これは<code>reader.Read()</code>が同時に実行された場合を保障されていないためでした。</p>

<p>このため<code>Read</code>の実行は同時に走らないようにするため</p>

<pre><code>func main() {
	reader := csv.NewReader(file)
	var wg sync.WaitGroup
	m := new(sync.Mutex)
	for i := 0; i &lt; 10; i++ {
		wg.Add(1)
		go func() {
			for {
				m.Lock()
				lines, isLast, err := getLines(reader)
				m.Unlock()
				...
				exec(lines)
				if isLast {
					wg.Done()
				}
			}
		}
	}
	wg.Wait()
}
</code></pre>

<p>のようにLockをとって動かすようにしたところ問題なく動くようになりました。</p>

<h2 id="結果">結果</h2>

<p>上記の並列の対応と一度に取得していた数を100から1000に変更したところ、5分以上かかっていたものが数秒で200を返すようになった。</p>

<p>また今回のインポートは順番を気にする必要なものではない場合のみ有効なものになります。</p>

          <a href="https://twitter.com/share" class="twitter-share-button" data-via="yudppp">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
<a href="http://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="standard-noballoon" data-hatena-bookmark-lang="en" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
          <div class="comment">
    <div>
        <a id="js-open-comment" class="event">
            show comment <span class="disqus-comment-count" data-disqus-url="https://blog.yudppp.com/posts/csv_fast_upload/"></span>
        </a>
    </div>
    <div id="disqus_thread"></div>
</div>
<script type="text/javascript">
     
     
    var openDiqus = function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//yudppp.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    document.all("js-open-comment").style.display = "none";
    };
    document.getElementById("js-open-comment").addEventListener('click',openDiqus,false);
</script>
        </div>
      </div>
    </main>
    
<div class="container">
	<div class="prevnext">
		
		<a class="pull-left" href="https://blog.yudppp.com/posts/golang_time_format/">
			<div>&lt;&lt; Go言語の忘れがちなtime fomatの話</div>
		</a>
		
		
		<a class="pull-right" href="https://blog.yudppp.com/posts/isucon2016/">
			<div>isucon6で人権を失いました。 &gt;&gt;</div>
		</a>
		
	</div>
</div>

    <div class="container">
  <a href="https://blog.yudppp.com/posts/whoami/">
    <div class="media profile">
      <div class="media-left">
        <img class="avatarholder" src="https://blog.yudppp.com/img/profile.svg" />
      </div>
      <div class="media-body">
        <div class="media-heading">@yudppp</div>
        <div class="media-content">Web engineer.</div>
      </div>
    </div>
  </a>
</div>

    <script src="https://blog.yudppp.com/js/lib.min.js"></script>
<script src="https://blog.yudppp.com/js/app.min.js"></script>
<script id="dsq-count-scr" src="//yudppp.disqus.com/count.js" async></script>
  </body>
</html>
