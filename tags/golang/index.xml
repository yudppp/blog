<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on ◯ △ □</title>
    <link>https://blog.yudppp.com/tags/golang/</link>
    <description>Recent content in Golang on ◯ △ □</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 09 Feb 2018 19:26:28 +0900</lastBuildDate>
    
	<atom:link href="https://blog.yudppp.com/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Vironとgoaでフロントのコード0でリソースの管理画面を作る</title>
      <link>https://blog.yudppp.com/posts/viron_and_goa/</link>
      <pubDate>Fri, 09 Feb 2018 19:26:28 +0900</pubDate>
      
      <guid>https://blog.yudppp.com/posts/viron_and_goa/</guid>
      <description>社内向けの管理画面を新しく作る機会があり、先日話題になっていたVironを使ってみることにしました。 Vironはフロントのコードを書かずにOpenAPIに則ったAPIがあれば管理画面を作ることが出来ます。 またgoaを使ってswagger.jsonを自動で生成させ、それを喰わせることによって管理画面を簡単に作って行きます。 本家はバックエンドはNodeJSでやっているようですが、どうしても色々考えるとGoで書きたい人なので頑張っていきました。
サンプルとして書いたコードをGithubにあげました。
https://github.com/yudppp/viron-goa
色々考えたのですがViron本体のコードは雑なセルフホスティングしています。
READMEにしたがって起動しログインします。(アイパスは空文字以外であればログインできます)
フロントのコードは書かずにリソースのリストが出てきました。 またRowについての更新処理や削除の処理がAPIを実装していれば行えます。
そもそもgoaも以前趣味で簡単なアプリケーション作ったくらいで詳しくなかったのでjwtのミドルウェア周りとsigininのAPIの実装あたりにやたらハマりフロントもフルスクラッチで自分で実装した方が速いんではないかと言う時期もありました。(1日くらい)
一度認証周りの実装を済ませてしまうと基本的なCRUD処理を行うリソースの追加が簡単に行えるようになりました。
大体検討開始から1週間で主なbaseの実装といくつかのリソースの管理のAPIの実装とDockerizeするとこまで出来ました。 今後実装すべきことしては権限管理とオートコンプリートのフォームの実装をしたいのですが、フロント側は既に実装されているそうなので追ってサーバーを実装して行くことによって簡単に使えるようになりそうです。</description>
    </item>
    
    <item>
      <title>Golangの時間のbefore/afterの話</title>
      <link>https://blog.yudppp.com/posts/time_before_after/</link>
      <pubDate>Thu, 14 Sep 2017 00:00:00 +0900</pubDate>
      
      <guid>https://blog.yudppp.com/posts/time_before_after/</guid>
      <description>英語の学が足らないので時間の比較を2回に1回間違えてしまうので、最近行っているバッドノウハウの共有します。
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;time&amp;quot; ) func main() { now := time.Now() yesterday := now.Add(-24 * time.Hour) fmt.Println(&amp;quot;now.After(yesterday) =&amp;gt;&amp;quot;, now.After(yesterday)) // -&amp;gt; true fmt.Println(&amp;quot;now.Before(yesterday) =&amp;gt;&amp;quot;, now.Before(yesterday)) // -&amp;gt; false fmt.Println(&amp;quot;yesterday.After(now) =&amp;gt;&amp;quot;, yesterday.After(now)) // -&amp;gt; false fmt.Println(&amp;quot;yesterday.Before(now) =&amp;gt;&amp;quot;, yesterday.Before(now)) // -&amp;gt; true }  https://play.golang.org/p/WkBHM4AO_X
毎回 after school は放課後だからと考えてよくわからなくなります。また含むのか含まないのかも毎回わからなくなります。
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;time&amp;quot; ) func main() { now := time.Now() yesterday := now.Add(-24 * time.Hour) fmt.Println(now.UnixNano() &amp;gt; yesterday.</description>
    </item>
    
    <item>
      <title>JSONをGolangのstructに変換する</title>
      <link>https://blog.yudppp.com/posts/json2struct/</link>
      <pubDate>Wed, 19 Jul 2017 00:00:00 +0900</pubDate>
      
      <guid>https://blog.yudppp.com/posts/json2struct/</guid>
      <description>先日のgolang.tokyo #7で自社パッケージの紹介LT大会にてLTでjson2structと言うパッケージの紹介をさせていただきました。
 スライドURL
細かい使い方や既存の同様のツールとの差異について書いていきたいと思います。
ツールの概要 GolangではJSONからデータを取得する際にあらかじめstructの定義をしておくことがありますが、その際に下記のようにタグ等など設定しなくてはならず、手間がかかってしまうのが面倒くさい。 また外部のAPI等でJSONの形式が複雑な場合その定義はより手間がかかってしまう。
{&amp;quot;url&amp;quot;: &amp;quot;http://blog.yudppp.com&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;Hello:)&amp;quot;, &amp;quot;status&amp;quot;: 1}  type Blog struct { Status int `json:&amp;quot;status&amp;quot;` Text string `json:&amp;quot;text&amp;quot;` URL string `json:&amp;quot;url&amp;quot;` }  それらを解決するために、JSONからGolangのstructの形式に変換するツールは幾つか既に存在しています・。
 json-to-go gojson  私はこれらのツールを使っていたのですが、実際に使う際に使いにくいポイントがあったので自分で作成しました。
json-to-go json-to-goはサイト上でJSONをstructに変換してくれるツールです。
https://mholt.github.io/json-to-go/
こちらの実行結果を見ていくと普段自分が書かないstructのnestや[]structといったものができてしまい、個人的には実用的でないと判断し使うことをやめました。
またJavaScript製でgofmtがされていないものが出力されます。
input
{&amp;quot;url&amp;quot;: &amp;quot;http://blog.yudppp.com&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;Hello:)&amp;quot;, &amp;quot;status&amp;quot;: 1, &amp;quot;categories&amp;quot;: [{&amp;quot;name&amp;quot;: &amp;quot;golang&amp;quot;}]}  output
type AutoGenerated struct { URL string `json:&amp;quot;url&amp;quot;` Text string `json:&amp;quot;text&amp;quot;` Status int `json:&amp;quot;status&amp;quot;` Categories []struct { Name string `json:&amp;quot;name&amp;quot;` } `json:&amp;quot;categories&amp;quot;` }  gojson https://github.</description>
    </item>
    
    <item>
      <title>Go言語の忘れがちなtime fomatの話</title>
      <link>https://blog.yudppp.com/posts/golang_time_format/</link>
      <pubDate>Tue, 06 Dec 2016 00:00:00 +0900</pubDate>
      
      <guid>https://blog.yudppp.com/posts/golang_time_format/</guid>
      <description>この記事はGo Advent Calendar 2016 - Qiitaの7日目の記事です。 apexの話でもしようと思ったのですが時間がなく別の記事を書くことにしました。
Golangを仕事で書き始めて、もう丸2年になりますが、未だに必要になると毎回ググって調べてから利用するものがあります。 その一つがtimeパッケージのフォーマットです。 GolangではいわゆるYYYYMMDDのような形式ではなく20060102といった特定の日時をベースにした文字列で表す必要があります。
123の順で振られていること、2006年なこと等なんとなくは覚えてきているのですが、確認をしないと不安で仕方なくなります。
この2年間で最低でも10回以上はgolang time formatでググり、その度にmattnさんの記事に辿り着いていました。 同じ記事を何度も見るのは自分に負けた気になるので悲しいです。
Golangの本家の実装を見るとわかるのですがtime/format.goの130行目あたりのnextStdChunkという関数でパースをしています。
これを基に判別表を作成しました。
   format about     January Month(long)   Jan Month(short)   1 Month Number   01 Month Number(zero埋め)   Monday WeekDay(long)   Mon WeekDay(short)   2 Day   _2 Day(space埋め)   02 Day(zero埋め)   15 Hour(24h)   3 Hour(12h)   03 Hour(12h,zero埋め)   4 Minute   04 Minute(zero埋め)   5 Second   05 Second(zero埋め)   2006 Year(long)   06 Year(short)   PM AM or PM   pm am or pm   MST TimeZone   Z0700 ISO8601TZ   Z070000 ISO8601TZ(seconds)   Z07 ISO8601TZ(short)   Z07:00 ISO8601TZ(colon)   Z07:00:00 ISO8601TZ(seconds/colon)   -0700 NumTimeZone   -070000 NumTimeZone(seconds)   -07 NumTimeZone(short)   -07:00 NumTimeZone(colon)   -07:00:00 NumTimeZone(seconds/colon)   .</description>
    </item>
    
    <item>
      <title>Golangで大きなcsvのインポートを速くする</title>
      <link>https://blog.yudppp.com/posts/csv_fast_upload/</link>
      <pubDate>Mon, 17 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://blog.yudppp.com/posts/csv_fast_upload/</guid>
      <description>はじめに Golangで大きなcsvファイルをパースして諸々の処理をしてインポートをする処理を書いていたのですが、明らかに遅く5分以上かかる処理になっていました。 そこでgoルーチンを導入して並列で実行することによって効率化を図りました。
対応前 func main() { // 1度に取得する量 bulkCount := 100 file, _ := os.Open(&amp;quot;./data.csv&amp;quot;) defer file.Close() reader := csv.NewReader(file) // ヘッダー行の取得 header, _ := reader.Read() for { lines := make([][]string, 0, bulkCount) isLast := false for i := 0; i &amp;lt; bulkCount; i++ { line, err := reader.Read() if err == io.EOF { isLast = true break } else if err != nil { panic(err) } lines = append(lines, line) } exec(lines) if isLast { break } } }  *一部のエラーは可読性のため捨てています</description>
    </item>
    
    <item>
      <title>net/httpでRedirectさせない</title>
      <link>https://blog.yudppp.com/posts/go-http-client-no-redirect/</link>
      <pubDate>Mon, 26 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://blog.yudppp.com/posts/go-http-client-no-redirect/</guid>
      <description> はじめに 302がちゃんとかえっているか確認したい。みたいな要件があり、なにも考えず
resp, err := http.Get(url)  のようにするとRedirectしたあとの結果を勝手にとってきてくれていた。
net/http/client.goをみてみるとdoFollowingRedirectsでリダイレクトを考慮して色々やっているようだった。
対応方法 下記のようにCheckRedirectを実装し、ハンドリングしてあげればよい。
package main import ( &amp;quot;errors&amp;quot; &amp;quot;net/http&amp;quot; &amp;quot;net/url&amp;quot; ) var RedirectAttemptedError = errors.New(&amp;quot;redirect&amp;quot;) func Check(urlApiEndPoint string) error { client := &amp;amp;http.Client{} client.CheckRedirect = func(req *http.Request, via []*http.Request) error { return RedirectAttemptedError } _, err := client.Get(urlApiEndPoint) if urlError, ok := err.(*url.Error); ok &amp;amp;&amp;amp; urlError.Err == RedirectAttemptedError { return nil } return errors.New(&amp;quot;don&#39;t redirect&amp;quot;) }  参考にしたもの  golang.org stackoverflow  </description>
    </item>
    
    <item>
      <title>golangで数字を三桁ごとでカンマ区切りにする</title>
      <link>https://blog.yudppp.com/posts/golang_num_separator/</link>
      <pubDate>Tue, 18 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://blog.yudppp.com/posts/golang_num_separator/</guid>
      <description>golangで金額扱うときに三桁ごとにカンマ区切りするあれがめんどくさかったのでメモ
golangはstringsパッケージにも文字列の反転がないので極力反転もさせず実装してみました。
func cast(price uint32) string { groupingSize := 3 groupingSeparator := &amp;quot;,&amp;quot; priceStr := fmt.Sprint(price) size := len(priceStr) sliceSize := (len(priceStr) + groupingSize - 1) / groupingSize priceSlice := make([]string, sliceSize) for i, _ := range priceSlice { start := size - (sliceSize-i)*groupingSize end := start + groupingSize if start &amp;lt; 0 { start = 0 } priceSlice[i] = priceStr[start:end] } return strings.Join(priceSlice, groupingSeparator) }  こんな感じになりました。
jsとかrubyとかだったら一行で書けるだろうに冗長的になってしまった。
[追記] tjのgo-configのcodeを追っていたらdustin/go-humanizeというものがでてきて</description>
    </item>
    
    <item>
      <title>【golang】JSTの時間をうまくParseする</title>
      <link>https://blog.yudppp.com/posts/golang-jst-parse/</link>
      <pubDate>Mon, 08 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://blog.yudppp.com/posts/golang-jst-parse/</guid>
      <description>golangでJSTの時間の文字列を変換するときに困ったのでTipsとして残しておきます。
2015-06-08 15:04:05 +0900のように+0900とついていた場合2006-01-02 15:04:05 -0700をformatとしてParseすればうまくいきます
package main import &amp;quot;fmt&amp;quot; import &amp;quot;time&amp;quot; func main() { target := `2015-06-08 15:04:05 +0900` t, _ := time.Parse(`2006-01-02 15:04:05 -0700`, target) fmt.Println(t.UTC()) }  上記は普通に指定すればできました。
問題はJSTで2015-06-08 15:04:05という値をParseしたい場合です。 色々実装をみてみたところ
package main import &amp;quot;fmt&amp;quot; import &amp;quot;time&amp;quot; func main() { target := `2015-06-08 15:04:05` loc, _ := time.LoadLocation(&amp;quot;Asia/Tokyo&amp;quot;) t, _ := time.ParseInLocation (`2006-01-02 15:04:05`, target, loc) fmt.Println(t.UTC()) }  time#ParseInLocationでlocationを指定してParseできるようでした。
あやうくParseしたい文字列に+0900の文字列追加したり、time.Date(t.Year(),...,loc)のようにするところでした。</description>
    </item>
    
  </channel>
</rss>